// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";

contract PriceTureNFT is ERC721URIStorage {
    AggregatorV3Interface internal priceFeed;
    mapping(uint256 => uint256) private _tokenPriceTiers;
    uint256[] _priceTiersThresholds;


    uint256 private _nextTokenId;
    

    // TODO turn this into function that receive argument as a JSON files and return the string
    // Metadata JSON for URI each stage of the NFT.
    string[] _tokenURIs = [
        "https://firebasestorage.googleapis.com/v0/b/priceture.appspot.com/o/0.json?alt=media&token=c30a17d6-31b2-4a16-8370-aa3bdcb03ff4",
        "https://firebasestorage.googleapis.com/v0/b/priceture.appspot.com/o/1.json?alt=media&token=dda15231-09f2-43da-91c1-3a2b697eb423",
        "https://firebasestorage.googleapis.com/v0/b/priceture.appspot.com/o/2.json?alt=media&token=bac78e83-505c-421c-af5a-bb0c91d24fbe",
        "https://firebasestorage.googleapis.com/v0/b/priceture.appspot.com/o/3.json?alt=media&token=6f459e5e-8c2d-4775-be19-18115288298b",
        "https://firebasestorage.googleapis.com/v0/b/priceture.appspot.com/o/4.json?alt=media&token=2e2b7980-7325-491a-b3b7-9d89cf48e2cb"
    ];

    // Helper function to get the latest price from Chainlink
     function getChainlinkDataFeedLatestAnswer() public view returns (int) {
        (
            ,
            int price,
            ,
            ,
        ) = priceFeed.latestRoundData();
        return price;
    }

    constructor() ERC721("Priceture", "PRCTURE") {

        // TODO turn this into function that receive arguments as latest pirce and price tiers thresholds to return the array of uint256
         // address of chainlink price on BTC/USD on Sepolia
        priceFeed = AggregatorV3Interface(0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43);
        int256 latestPrice = getChainlinkDataFeedLatestAnswer();
        _priceTiersThresholds.push(uint256(latestPrice * 98/100));
        _priceTiersThresholds.push(uint256(latestPrice * 99/100));
        _priceTiersThresholds.push(uint256(latestPrice));
        _priceTiersThresholds.push(uint256(latestPrice * 101/100));
        _priceTiersThresholds.push(uint256(latestPrice * 102/100));
    }

    // function to mint to the wallet owner
    function safeMint(
        address to
    ) public returns (uint256) {
        uint256 tokenId = _nextTokenId++;
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, _tokenURIs[2]);
        return tokenId;
    }

       // Function to update the token URI based on the current price tier
    function updateTokenURI(uint256 tokenId) public {
        int256 latestPrice = getChainlinkDataFeedLatestAnswer();
        uint256 currentTier = determinePriceTier(latestPrice);
        _tokenPriceTiers[tokenId] = currentTier;
        _setTokenURI(tokenId, _tokenURIs[currentTier]);

    }

     // Helper function to determine the price tier based on the latest price
     function determinePriceTier(int256 latestPrice) public view returns (uint256) {
        for (uint256 i = _priceTiersThresholds.length; i>0; i--) {
            if (uint256(latestPrice) >= _priceTiersThresholds[i]) {
                return i;
            }
        }
        // If price doesn't fall into any tier, return the first tier
        return 0;
    }

    // TODO performUpkeep function everyday to update the token URI based on the current price tier

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
            mildBirthday(0);
        }
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }
}

